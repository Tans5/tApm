#include <iostream>

#include "dex/dex_file.h"
#include "dex/dex_file_layout.h"
#include "dex/dex_instruction.h"
#include "dex/dex_instruction_utils.h"
#include "dex/invoke_type.h"

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, EncodedArrayValueIterator::ValueType rhs) {
  switch (rhs) {
    case EncodedArrayValueIterator::kByte: os << "Byte"; break;
    case EncodedArrayValueIterator::kShort: os << "Short"; break;
    case EncodedArrayValueIterator::kChar: os << "Char"; break;
    case EncodedArrayValueIterator::kInt: os << "Int"; break;
    case EncodedArrayValueIterator::kLong: os << "Long"; break;
    case EncodedArrayValueIterator::kFloat: os << "Float"; break;
    case EncodedArrayValueIterator::kDouble: os << "Double"; break;
    case EncodedArrayValueIterator::kMethodType: os << "MethodType"; break;
    case EncodedArrayValueIterator::kMethodHandle: os << "MethodHandle"; break;
    case EncodedArrayValueIterator::kString: os << "String"; break;
    case EncodedArrayValueIterator::kType: os << "Type"; break;
    case EncodedArrayValueIterator::kField: os << "Field"; break;
    case EncodedArrayValueIterator::kMethod: os << "Method"; break;
    case EncodedArrayValueIterator::kEnum: os << "Enum"; break;
    case EncodedArrayValueIterator::kArray: os << "Array"; break;
    case EncodedArrayValueIterator::kAnnotation: os << "Annotation"; break;
    case EncodedArrayValueIterator::kNull: os << "Null"; break;
    case EncodedArrayValueIterator::kBoolean: os << "Boolean"; break;
    default: os << "EncodedArrayValueIterator::ValueType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, LayoutType rhs) {
  switch (rhs) {
    case LayoutType::kLayoutTypeHot: os << "LayoutTypeHot"; break;
    case LayoutType::kLayoutTypeSometimesUsed: os << "LayoutTypeSometimesUsed"; break;
    case LayoutType::kLayoutTypeStartupOnly: os << "LayoutTypeStartupOnly"; break;
    case LayoutType::kLayoutTypeUsedOnce: os << "LayoutTypeUsedOnce"; break;
    case LayoutType::kLayoutTypeUnused: os << "LayoutTypeUnused"; break;
    case LayoutType::kLayoutTypeCount: os << "LayoutTypeCount"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, DexLayoutSections::SectionType rhs) {
  switch (rhs) {
    case DexLayoutSections::SectionType::kSectionTypeCode: os << "SectionTypeCode"; break;
    case DexLayoutSections::SectionType::kSectionTypeStrings: os << "SectionTypeStrings"; break;
    case DexLayoutSections::SectionType::kSectionCount: os << "SectionCount"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, Instruction::Signatures rhs) {
  switch (rhs) {
    case Instruction::kPackedSwitchSignature: os << "PackedSwitchSignature"; break;
    case Instruction::kSparseSwitchSignature: os << "SparseSwitchSignature"; break;
    case Instruction::kArrayDataSignature: os << "ArrayDataSignature"; break;
    default: os << "Instruction::Signatures[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, Instruction::Format rhs) {
  switch (rhs) {
    case Instruction::k10x: os << "10x"; break;
    case Instruction::k12x: os << "12x"; break;
    case Instruction::k11n: os << "11n"; break;
    case Instruction::k11x: os << "11x"; break;
    case Instruction::k10t: os << "10t"; break;
    case Instruction::k20t: os << "20t"; break;
    case Instruction::k22x: os << "22x"; break;
    case Instruction::k21t: os << "21t"; break;
    case Instruction::k21s: os << "21s"; break;
    case Instruction::k21h: os << "21h"; break;
    case Instruction::k21c: os << "21c"; break;
    case Instruction::k23x: os << "23x"; break;
    case Instruction::k22b: os << "22b"; break;
    case Instruction::k22t: os << "22t"; break;
    case Instruction::k22s: os << "22s"; break;
    case Instruction::k22c: os << "22c"; break;
    case Instruction::k32x: os << "32x"; break;
    case Instruction::k30t: os << "30t"; break;
    case Instruction::k31t: os << "31t"; break;
    case Instruction::k31i: os << "31i"; break;
    case Instruction::k31c: os << "31c"; break;
    case Instruction::k35c: os << "35c"; break;
    case Instruction::k3rc: os << "3rc"; break;
    case Instruction::k45cc: os << "45cc"; break;
    case Instruction::k4rcc: os << "4rcc"; break;
    case Instruction::k51l: os << "51l"; break;
    case Instruction::kInvalidFormat: os << "InvalidFormat"; break;
    default: os << "Instruction::Format[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, Instruction::IndexType rhs) {
  switch (rhs) {
    case Instruction::kIndexUnknown: os << "IndexUnknown"; break;
    case Instruction::kIndexNone: os << "IndexNone"; break;
    case Instruction::kIndexTypeRef: os << "IndexTypeRef"; break;
    case Instruction::kIndexStringRef: os << "IndexStringRef"; break;
    case Instruction::kIndexMethodRef: os << "IndexMethodRef"; break;
    case Instruction::kIndexFieldRef: os << "IndexFieldRef"; break;
    case Instruction::kIndexFieldOffset: os << "IndexFieldOffset"; break;
    case Instruction::kIndexVtableOffset: os << "IndexVtableOffset"; break;
    case Instruction::kIndexMethodAndProtoRef: os << "IndexMethodAndProtoRef"; break;
    case Instruction::kIndexCallSiteRef: os << "IndexCallSiteRef"; break;
    case Instruction::kIndexMethodHandleRef: os << "IndexMethodHandleRef"; break;
    case Instruction::kIndexProtoRef: os << "IndexProtoRef"; break;
    default: os << "Instruction::IndexType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, Instruction::ExtendedFlags rhs) {
  switch (rhs) {
    case Instruction::kAdd: os << "Add"; break;
    case Instruction::kSubtract: os << "Subtract"; break;
    case Instruction::kMultiply: os << "Multiply"; break;
    case Instruction::kDivide: os << "Divide"; break;
    case Instruction::kRemainder: os << "Remainder"; break;
    case Instruction::kAnd: os << "And"; break;
    case Instruction::kOr: os << "Or"; break;
    case Instruction::kXor: os << "Xor"; break;
    case Instruction::kShl: os << "Shl"; break;
    case Instruction::kShr: os << "Shr"; break;
    case Instruction::kUshr: os << "Ushr"; break;
    case Instruction::kCast: os << "Cast"; break;
    case Instruction::kStore: os << "Store"; break;
    case Instruction::kLoad: os << "Load"; break;
    case Instruction::kClobber: os << "Clobber"; break;
    case Instruction::kRegCFieldOrConstant: os << "RegCFieldOrConstant"; break;
    case Instruction::kRegBFieldOrConstant: os << "RegBFieldOrConstant"; break;
    default: os << "Instruction::ExtendedFlags[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, DexInvokeType rhs) {
  switch (rhs) {
    case kDexInvokeVirtual: os << "DexInvokeVirtual"; break;
    case kDexInvokeSuper: os << "DexInvokeSuper"; break;
    case kDexInvokeDirect: os << "DexInvokeDirect"; break;
    case kDexInvokeStatic: os << "DexInvokeStatic"; break;
    case kDexInvokeInterface: os << "DexInvokeInterface"; break;
    case kDexInvokeTypeCount: os << "DexInvokeTypeCount"; break;
    default: os << "DexInvokeType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, DexMemAccessType rhs) {
  switch (rhs) {
    case kDexMemAccessWord: os << "DexMemAccessWord"; break;
    case kDexMemAccessWide: os << "DexMemAccessWide"; break;
    case kDexMemAccessObject: os << "DexMemAccessObject"; break;
    case kDexMemAccessBoolean: os << "DexMemAccessBoolean"; break;
    case kDexMemAccessByte: os << "DexMemAccessByte"; break;
    case kDexMemAccessChar: os << "DexMemAccessChar"; break;
    case kDexMemAccessShort: os << "DexMemAccessShort"; break;
    case kDexMemAccessTypeCount: os << "DexMemAccessTypeCount"; break;
    default: os << "DexMemAccessType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, InvokeType rhs) {
  switch (rhs) {
    case kStatic: os << "static"; break;
    case kDirect: os << "direct"; break;
    case kVirtual: os << "virtual"; break;
    case kSuper: os << "super"; break;
    case kInterface: os << "interface"; break;
    case kPolymorphic: os << "polymorphic"; break;
    case kCustom: os << "custom"; break;
    default: os << "InvokeType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

