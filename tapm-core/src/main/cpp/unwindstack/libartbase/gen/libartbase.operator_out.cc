#include <iostream>

#include "arch/instruction_set.h"
#include "base/allocator.h"
#include "base/unix_file/fd_file.h"

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, InstructionSet rhs) {
  switch (rhs) {
    case InstructionSet::kNone: os << "None"; break;
    case InstructionSet::kArm: os << "Arm"; break;
    case InstructionSet::kArm64: os << "Arm64"; break;
    case InstructionSet::kThumb2: os << "Thumb2"; break;
    case InstructionSet::kRiscv64: os << "Riscv64"; break;
    case InstructionSet::kX86: os << "X86"; break;
    case InstructionSet::kX86_64: os << "X86_64"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, AllocatorTag rhs) {
  switch (rhs) {
    case kAllocatorTagHeap: os << "AllocatorTagHeap"; break;
    case kAllocatorTagMonitorList: os << "AllocatorTagMonitorList"; break;
    case kAllocatorTagClassTable: os << "AllocatorTagClassTable"; break;
    case kAllocatorTagInternTable: os << "AllocatorTagInternTable"; break;
    case kAllocatorTagMaps: os << "AllocatorTagMaps"; break;
    case kAllocatorTagLOS: os << "AllocatorTagLOS"; break;
    case kAllocatorTagSafeMap: os << "AllocatorTagSafeMap"; break;
    case kAllocatorTagLOSMaps: os << "AllocatorTagLOSMaps"; break;
    case kAllocatorTagReferenceTable: os << "AllocatorTagReferenceTable"; break;
    case kAllocatorTagHeapBitmap: os << "AllocatorTagHeapBitmap"; break;
    case kAllocatorTagHeapBitmapLOS: os << "AllocatorTagHeapBitmapLOS"; break;
    case kAllocatorTagMonitorPool: os << "AllocatorTagMonitorPool"; break;
    case kAllocatorTagLOSFreeList: os << "AllocatorTagLOSFreeList"; break;
    case kAllocatorTagVerifier: os << "AllocatorTagVerifier"; break;
    case kAllocatorTagRememberedSet: os << "AllocatorTagRememberedSet"; break;
    case kAllocatorTagModUnionCardSet: os << "AllocatorTagModUnionCardSet"; break;
    case kAllocatorTagModUnionReferenceArray: os << "AllocatorTagModUnionReferenceArray"; break;
    case kAllocatorTagJNILibraries: os << "AllocatorTagJNILibraries"; break;
    case kAllocatorTagCompileTimeClassPath: os << "AllocatorTagCompileTimeClassPath"; break;
    case kAllocatorTagOatFile: os << "AllocatorTagOatFile"; break;
    case kAllocatorTagDexFileVerifier: os << "AllocatorTagDexFileVerifier"; break;
    case kAllocatorTagRosAlloc: os << "AllocatorTagRosAlloc"; break;
    case kAllocatorTagCount: os << "AllocatorTagCount"; break;
    default: os << "AllocatorTag[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by art/tools/generate_operator_out.py --- do not edit!
namespace unix_file {
std::ostream& operator<<(std::ostream& os, FdFile::GuardState rhs) {
  switch (rhs) {
    case FdFile::GuardState::kBase: os << "Base"; break;
    case FdFile::GuardState::kFlushed: os << "Flushed"; break;
    case FdFile::GuardState::kClosed: os << "Closed"; break;
    case FdFile::GuardState::kNoCheck: os << "NoCheck"; break;
  }
  return os;
}
}  // namespace unix_file

